TDScriptLeafNode{#name:'serviceTask',#contents:'[ :topez :objIn :tokens :command :commandNode | 
| opts args |
\"for help: ./serviceTask -h\"
command
  getOptsMixedLongShort:
    {#(\'help\' $h #\'none\').
    #(\'task\' nil #\'optional\').
    #(\'poll\' nil #\'optional\').
    #(\'addToQueue\' nil #\'none\').
    #(\'reset\' nil #\'none\').
    #(\'status\' nil #\'none\')}
  optionsAndArguments: [ :options :operands | 
    opts := options.
    args := operands ].
opts
  at: \'help\'
  ifAbsent: [ 
    | response taskClass taskDictionary |
    taskDictionary := Smalltalk
      at: #\'SERVICE_TASK_DICTIONARY\'
      ifAbsent: [ Smalltalk at: #\'SERVICE_TASK_DICTIONARY\' put: Dictionary new ].
    taskClass := WAGemStoneServiceTask.
    opts
      at: \'task\'
      ifPresent: [ :taskId | 
        taskId
          ifNil: [ 
            | task  |
            task := taskClass 
              value: WAGemStoneServiceTask 
  value: (WAGemStoneServiceExampleTimeInLondon 
           url: \'http://www.time.org/zones/Europe/London.php\')
.
            taskDictionary at: task id put: task.
            response := task ]
          ifNotNil: [ 
            | task |
            System commit.\t\"ensure that we are accessing latest state of task\"
            response := task := taskDictionary at: taskId asNumber.
            opts
              at: \'addToQueue\'
              ifPresent: [ :ignored | 
                task addToQueue.
                System commit\t\"so that service vm can see new queue entry\" ].
            opts
              at: \'poll\'
              ifPresent: [ :limitArg | 
                | limit count |
                limit := 10.
                limitArg ifNotNil: [ limit := limitArg asNumber ].
                count := 0.
                [ 
                System abort.\t\"so that service vm can see new queue entry\"
                task finishedStep not and: [ count <= limit ] ]
                  whileTrue: [ 
                    (Delay forSeconds: 1) wait.
                    count := count + 1 ].
                System abort.
                task finishedStep
                  ifTrue: [ response := task ]
                  ifFalse: [ response := task -> (\'not finished after \' , count printString , \' seconds\') ] ] ] ]
      ifAbsent: [ 
        opts at: \'reset\' ifPresent: [ :ignored | response := taskClass reset ].
        opts
          at: \'status\'
          ifPresent: [ :ignored | 
            | dict |
            dict := Dictionary new
              at: \'queue\' put: taskClass queue;
              at: \'inProcess\' put: taskClass inProcessCollection;
              at: \'high water\' put: taskClass idHighWater;
              at: \'tasks\' put: taskDictionary;
              yourself.
            dict edit: topez.
            response := dict ] ].
    response ]
  ifPresent: [ :ignored | 
    TDManPage
      viewManPage:
        \'NAME
  serviceTask - serviceTask sript utility template
SYNOPSIS
  serviceTask [-h|--help] [--reset] [--status]
  serviceTask --task[=<task-id>] [--addToQueue] [--poll[=<poll-limit>]
DESCRIPTION
EXAMPLES
  ./serviceTask --help
  ./serviceTask --reset                # clear service task queues and counters
                                          #   only use reset when service is not
                                          #   running
  ./serviceTask --status               # state of service task engine

  ./serviceTask --task                 # create a new task
  ./serviceTask --task=3               # access task #3
  ./serviceTask --task=3 --addToQueue  # schedule task #3 to process next step
  ./serviceTask --task=3 --poll=10     # poll until task #3 finished step (10 tries)
\'
      topez: topez ] ]',#creationTime:DateAndTime['2014-06-08T12:03:24.639317035675-07:00'],#modificationTime:DateAndTime['2014-06-08T17:10:11.1408710479736-07:00']}